---
title: "Home Temperature Monitoring: Part 3"
date: "2025-09-10"
description: "In Part 3, I work on the implementation of the sensor API and the backend service. Specifically, I focus on creating an API for the Raspberry Pi sensors to provide temperature readings and building a backend service in Go to collect and store this data in a MySQL database."
tags: ["python", "raspberry-pi", "go", "mysql", "home-automation", "polymorphism", "flask", "interfaces"]
published: true
---

# Implementing the sensor API and backend service

## Sensor API

The first step in the implementation is to update the Raspberry Pi sensor software to provide an API for data collection. The existing Python script that reads the temperature from the DS18B20 sensors will be modified to run as a long-lived service. This service will expose an HTTP endpoint that can be called to trigger a temperature reading and return the result in JSON format.

The API really only needs a single endpoint in this case. Much of the functionality can be ported over from the existing solution.

### Implementation details

To create the API, I will use Flask, a lightweight web framework for Python. Flask is easy to set up and has a simple routing mechanism, making it ideal for this small service.
Here's a basic outline of the sensor API:

```python
import os
from ds18b20_sensor import DS18B20TempSensor
from dotenv import load_dotenv
from flask import Flask, request, jsonify, abort

app = Flask(__name__)

load_dotenv()

@app.get("/temperature")
def get_temperature():
    try:
        sensor = DS18B20TempSensor()
        return jsonify(sensor.collect_data())
    except Exception as e:
        abort(500)

@app.errorhandler(500)
def internal_error(error):
    return {"message": "couldn't take a reading"},500
```

As shown above, the API has a single endpoint `/temperature` that, when called, reads the temperature from the DS18B20 sensor and returns it in JSON format. If there's an error while reading the sensor, it returns a 500 status code with an appropriate message. There really isn't anything more that needs to be done here. The sensors are not named, that is the responsibility of the Sensor Hub service.

Down the line, replacing this architecture with something like MQTT might be a good idea, but for now, this simple HTTP API will suffice. This is probably sending more data than is necessary, but it works.

## Backend service

The next step is to create a backend service that will periodically call the sensor API to collect temperature data and store it in a database. For this, I will use Go, as it is well-suited for building efficient and scalable backend services.

### Implementation details

The http package in Go should be a good fit for requesting the temperature data from the sensor API. The database will come later, for now, I just need to get the data from the APIs to the service.

The backend needs to be made aware of the sensors it needs to collect data from. For this, I will use an openapi.yaml file to define the sensors. This file will be read by the backend service at startup to discover the sensors. Any config file would do, but I like the idea of using OpenAPI for this, as it provides a clear structure and can be easily extended in the future if needed.
```yaml
openapi: 3.1.0
info:
  title: Sensor API
  description: The API for the sensors located around the home.
  version: 0.0.1

servers:
  - url: http://home.upstairs-pi:5000/
    description: Raspberry Pi located in an upstairs room
    variables:
      sensor_name:
        default: Upstairs
        description: The name of the sensor. This isn't really ever changed.
      sensor_type:
        default: Temperature
        description: The type of sensor. This isn't really ever changed.
  - url: http://home.downstairs-pi:5000/
    description: Raspberry Pi located in a downstairs room
    variables:
      sensor_name:
        default: Downstairs
        description: The name of the sensor. This isn't really ever changed.
      sensor_type:
        default: Temperature
        description: The type of sensor. This isn't really ever changed.
paths:
...
```

The file above defines two sensors, each with a unique URL and a name. The backend service will read this file at startup to discover the sensors it needs to collect data from. 

```go 
func DiscoverSensors() error {
	fileData, err := os.ReadFile(appProps.APPLICATION_PROPERTIES["openapi.yaml.location"])
	if err != nil {
		log.Printf("Cannot find the openapi.yaml file for the temperature sensors: %s\n", err)
		return err
	}
	var servers types.SensorServers

	err = yaml.Unmarshal(fileData, &servers)
	if err != nil {
		log.Printf("Cannot unmarshal the yaml into a map: %s\n", err)
		return err
	}
	sensors = make([]ISensor, 0)

	for _, value := range servers.Servers {
		sensorName := value.Variables["sensor_name"].Default
		url := value.Url
		sensorType := value.Variables["sensor_type"].Default
		switch sensorType {
		case "Temperature":
			sensors = append(sensors, NewTemperatureSensor(sensorName, url))
		default:
			log.Printf("Unknown sensor type %s for sensor %s, skipping...\n", sensorType, sensorName)
			continue
		}
	}
	log.Printf("Discovered sensors:")
	for _, sensor := range sensors {
		log.Printf(" - %s\n", sensor.ToString())
	}
	return nil
}
```

This function reads the yaml file, unmarshals it into a struct, and creates a list of sensors based on the information in the file. The sensors are stored in a global variable for later use.

Requesting the data from a sensor can be done like this:

```go
// This function fetches the readings from all known sensors.
// If at least one sensor provides readings successfully, it returns nil.
// If no readings are successfully collected, it returns an error.
var takeReadingsFromAllSensors = func() error {
	if len(sensors) == 0 {
		log.Println("No sensors discovered, cannot take readings.")
		return fmt.Errorf("no sensors discovered")
	}
	count := 0
	for _, sensor := range sensors {
		log.Printf("Taking reading from sensor: %s\n", sensor.GetName())
		err := sensor.TakeReading(true)
		if err != nil {
			log.Printf("Error taking reading from sensor %s: %s\n", sensor.GetName(), err)
		}
		count++
	}
	if count == 0 {
		return fmt.Errorf("no readings collected from any sensors")
	}
	return nil
}
```

This function iterates over all known sensors, calls their `TakeReading` method, and logs any errors encountered. If at least one reading is successfully collected, it returns nil; otherwise, it returns an error.

The sensors are generic interfacecs that can represent any type of sensor. For now, I only have the `Temperature` sensors, but this design allows for easy extension in the future if I decide to add more sensor types. Go's interface system makes this kind of polymorphism straightforward.

```go 
type ISensor interface {
	TakeReading(persist bool) error
	ToString() string
	GetName() string
	GetURL() string
}
```

The meat of the data collection is done in the implementation of the `TakeReading` method for each sensor type. For the temperature sensors, it looks like this:

```go
// TakeReading fetches the current temperature from the sensor's API,
// updates the latestReading field, and optionally persists the reading to the database.
// If persist is true, it also checks if an alert email needs to be sent based on the reading.
func (ts *TemperatureSensor) TakeReading(persist bool) error {
	if ts.name == "" || ts.url == "" {
		return fmt.Errorf("sensor name or URL cannot be empty")
	}
	readingUrl := ts.url + "/temperature"
	resp, err := http.Get(readingUrl)
	if err != nil {
		log.Printf("Issue fetching temperature from sensor %s: %s\n", ts.name, err)
		return err
	}
	defer resp.Body.Close()
	response := new(types.RawTemperatureReading)
	err = json.NewDecoder(resp.Body).Decode(response)
	if err != nil {
		log.Printf("Issue reading request body from sensor %s: %s\n", ts.name, err)
		return err
	}
	nameTaggedResponse := utils.ConvertRawSensorReadingToAPIReading(ts.name, *response)
	log.Printf("Sensor %s reading: %v\n", ts.name, nameTaggedResponse)

	ts.latestReading = nameTaggedResponse

	// insert into database
	if !persist {
		return nil
	}

	readings := make([]types.APIReading, 0)
	readings = append(readings, nameTaggedResponse)
	err = database.AddListOfRawReadings(readings)
	if err != nil {
		log.Printf("Issue persisting readings to database: %s\n", err)
		return nil
	}
	err = smtp.SendAlertEmailIfNeeded(readings)
	if err != nil {
		log.Printf("Failed to send alerts: %s", err)
	}

	return nil
}
```

With the data collection in place, the next step is to set up a scheduler to call this function periodically. For this, I will use a bit of Go concurrency with a ticker to trigger the readings at regular intervals.

```go
func StartPeriodicSensorCollection() {
	intervalStr := appProps.APPLICATION_PROPERTIES["sensor.collection.interval"]
	intervalSec, err := strconv.Atoi(intervalStr)
	if err != nil {
		log.Printf("Invalid sensor.collection.interval value: %s, defaulting to 60 seconds", intervalStr)
		intervalSec = 60
	}
	go func() {
		ticker := time.NewTicker(time.Duration(intervalSec) * time.Second)
		defer ticker.Stop()
		for {
			err := takeReadingsFromAllSensors()
			if err != nil {
				log.Printf("Error taking periodic readings from sensors: %s", err)
			}
			<-ticker.C
		}
	}()
}
```

This function reads the interval from the application properties, defaults to 60 seconds if the value is invalid, and starts a goroutine that uses a ticker to collect readings from all sensors at the specified interval. 

The backend service is now able to periodically collect temperature data. The next step is to set up the database to store the readings, then I can work on an API to service the frontend.

### Database implementation

For the database, I will use MySQL. The database schema will include a table for storing temperature readings, with fields for the sensor name, temperature value, and timestamp.

Here's a basic outline of the database schema:

```sql
CREATE TABLE IF NOT EXISTS %s (
			id INT AUTO_INCREMENT,
			sensor_name TEXT NOT NULL,
			time DATETIME NOT NULL,
			temperature FLOAT(4) NOT NULL,
			PRIMARY KEY (id)
		);
```

This table will store each temperature reading along with the sensor name and the time the reading was taken. The `id` field is an auto-incrementing primary key to uniquely identify each record.

After speaking to a friend, I put in some indexes on the `sensor_name` and `time` fields to improve query performance, especially for queries that filter by sensor or time range.

```sql
CREATE INDEX idx_time ON temperature_readings (time DESC);
CREATE INDEX idx_sensor_name ON temperature_readings (sensor_name(16));
```

To do this in Go, using the `database/sql` package, it is really just a case of running DB.Exec with the above SQL statements:

```go
DB.Exec(`CREATE INDEX idx_time ON temperature_readings (time DESC);`)
```

To tie this together, the backend needs to have some functions for retrieving and storing the data in the database. To add the readings, I will create a function that takes a list of `APIReading` structs and inserts them into the database.

```go
func AddListOfRawReadings(readings []types.APIReading) error {
	convertedDbReadings := utils.ConvertAPIReadingsToDbReadings(readings)
	query := fmt.Sprintf("INSERT INTO %s (sensor_name, time, temperature) VALUES (?, ?, ?)", TableTemperatureReadings)
	for _, reading := range convertedDbReadings {
		_, err := DB.Exec(query, reading.SensorName, reading.Time, strconv.FormatFloat(reading.Temperature, 'f', -1, 64))
		if err != nil {
			return fmt.Errorf("issue persisting readings to database: %s", err)
		}
		log.Printf("Saved a reading from Sensor(%s) into the database", reading.SensorName)
	}
	return nil
}
```

For retrieving the data, I will create a function that takes a time range and returns the corresponding temperature readings. Since I will be graphing the data, there will always be a need to get readings between two timestamps.

```go
// This function will fetch readings from the database between the specified start and end dates.
// It will log the readings or any errors encountered during the process.
var GetReadingsBetweenDates = func(tableName string, startDate string, endDate string) ([]types.APIReading, error) {
	if tableName != TableTemperatureReadings {
		return nil, fmt.Errorf("invalid table name: %s", tableName)
	}

	query := fmt.Sprintf("SELECT * FROM %s WHERE time BETWEEN ? AND ? ORDER BY time ASC", tableName)

	rows, err := DB.Query(query, startDate, endDate)
	if err != nil {
		return nil, fmt.Errorf("error fetching readings between %s and %s: %w", startDate, endDate, err)
	}
	defer rows.Close()
	var readings []types.DbReading
	for rows.Next() {
		var reading types.DbReading

		err := rows.Scan(&reading.Id, &reading.SensorName, &reading.Time, &reading.Temperature)
		if err != nil {
			log.Printf("Error scanning row: %s", err)
			continue
		}
		readings = append(readings, reading)
	}
	if err = rows.Err(); err != nil {
		log.Printf("Error iterating over rows: %s", err)
		return nil, fmt.Errorf("error iterating over rows: %s", err)
	}
	apiReadings := utils.ConvertDbReadingsToApiReadings(readings)
	return apiReadings, nil
}
```

There is some risky string formatting in the SQL query construction, but since the table name is validated against a constant, it should be safe. The start and end dates are passed as parameters to the query, which helps prevent SQL injection. I consume the tableName through the parameters to allow for extensibility of this function in the future.

This function constructs a SQL query to select readings from the specified table within the given time range, executes the query, and scans the results into a slice of `APIReading` structs. 

The function is named "var GetReadingsBetweenDates" to allow for easier mocking in tests. Go does not have a built-in mocking framework, so using function variables is a common pattern to facilitate testing.

With the database functions in place, the backend service is now capable of storing and retrieving temperature data. The next step is to create an API for the frontend to access this data, which will be covered in the next part of this series.

## Summary

In this part of the series, I implemented the sensor API on the Raspberry Pi to provide temperature readings and created a backend service in Go to periodically collect and store this data in a MySQL database. The backend service includes functions for adding and retrieving temperature readings, setting the stage for building a frontend to visualize the data. In the next part, I will focus on developing the API for the backend, and the frontend application to display the temperature data in a user-friendly manner.

As always, the code for this project is available on [GitHub](https://github.com/tom-molotnikoff/home-temperature-monitoring). If you have any questions or suggestions, feel free to reach out!